/**
 * Storage abstraction for WhyTab.
 *
 * Data shape in chrome.storage.local:
 * {
 *   collections: [ ... ],          // see below
 *   urlIndex: { [url]: count },    // fast duplicate lookup
 *   settings: { ... },
 *   actionLog: [ { type, timestamp, tabId?, collectionId?, metadata? } ]
 * }
 *
 * Collection shape:
 * {
 *   id: string,
 *   name: string,
 *   createdAt: number,
 *   autoTitleType?: string,
 *   isPinned: boolean,
 *   notes: string,
 *   tabs: [
 *     {
 *       id: string,
 *       url: string,
 *       title: string,
 *       favIconUrl: string,
 *       savedAt: number,
 *       archived: boolean,
 *       tags: string[]
 *     }
 *   ]
 * }
 *
 * urlIndex: A denormalized { url → count } object kept in sync whenever
 * tabs are added/removed. This gives O(1) duplicate lookups instead of
 * scanning every tab. We rebuild it from scratch if it ever gets out of
 * sync (e.g. after import or version upgrade).
 *
 * Why chrome.storage.local instead of localStorage?
 * - Available in service workers (localStorage isn't)
 * - Up to 10 MB vs 5 MB
 * - Async API that won't block the UI
 * - Accessible from popup, background, and options pages without message passing
 */

const DEFAULT_SETTINGS = {
  showItemUrls: false,
  useContextualAutoTitles: true,
  closeAfterSave: 'always',   // 'always' | 'never' | 'ask'
  showDuplicateWarnings: true,
  closeTabsOnSave: true,      // close browser tabs after saving
  accordionState: {},
  collectionSort: 'newest',
  showSortControl: false,
  autoArchiveInactiveSessions: true,
};

const LEGACY_TIMESTAMP_REGEX = /^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) \d{1,2}, \d{4} \u00b7 \d{1,2}:\d{2}(?: \u00b7 (Left|Right))?$/;
const LEGACY_WEEKDAY_REGEX = /^(Sunday|Monday|Tuesday|Wednesday|Thursday|Friday|Saturday)\s+(morning|afternoon|evening|night)$/i;
const CLASSIC_TIMEOFDAY_REGEX = /^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) \d{1,2}\s+(morning|afternoon|evening|night)(?: \u00b7 (Left|Right))?$/i;
const TITLE_WITH_TIMESTAMP_REGEX = /^.+\s+—\s+((Sunday|Monday|Tuesday|Wednesday|Thursday|Friday|Saturday)\s+(morning|afternoon|evening|night)|(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) \d{1,2}\s+(morning|afternoon|evening|night))$/i;

function isLikelyAutoGeneratedTitle(name = '') {
  const normalized = String(name || '').trim();
  if (!normalized) return true;
  return LEGACY_TIMESTAMP_REGEX.test(normalized)
    || LEGACY_WEEKDAY_REGEX.test(normalized)
    || CLASSIC_TIMEOFDAY_REGEX.test(normalized)
    || TITLE_WITH_TIMESTAMP_REGEX.test(normalized)
    || normalized.startsWith('Mostly ') && TITLE_WITH_TIMESTAMP_REGEX.test(normalized.replace(/^Mostly\s+/, ''));
}

function normalizeCollectionMetadata(collections) {
  let changed = false;
  const next = collections.map((col) => {
    let normalizedCol = col;
    const createdAt = normalizedCol.createdAt || Date.now();

    if (normalizedCol.isUserNamed === undefined) {
      normalizedCol = { ...normalizedCol, isUserNamed: !isLikelyAutoGeneratedTitle(normalizedCol.name) };
      changed = true;
    }

    if (normalizedCol.lastInteractedAt === undefined || normalizedCol.lastInteractedAt === null) {
      normalizedCol = { ...normalizedCol, lastInteractedAt: createdAt };
      changed = true;
    }

    return normalizedCol;
  });

  return { collections: changed ? next : collections, changed };
}
function formatTimeOfDayTitle(date) {
  const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
  return `${months[date.getMonth()]} ${date.getDate()} ${WhyTabTime.timeOfDayLabel(date)}`;
}

function normalizeAutoTitles(collections) {
  let changed = false;
  const next = collections.map((col) => {
    let normalizedCol = col;
    if (col.archived === undefined) {
      changed = true;
      normalizedCol = { ...normalizedCol, archived: false };
    }
    if (Array.isArray(normalizedCol.tabs)) {
      const nextTabs = normalizedCol.tabs.map((tab) => {
        if (tab.archived === undefined) {
          changed = true;
          return { ...tab, archived: false };
        }
        return tab;
      });
      if (nextTabs !== normalizedCol.tabs) {
        normalizedCol = { ...normalizedCol, tabs: nextTabs };
      }
    }

    const createdAt = normalizedCol.createdAt || Date.now();
    const baseName = formatTimeOfDayTitle(new Date(createdAt));

    if (normalizedCol.autoTitleType === 'timeOfDay') {
      if (normalizedCol.name !== baseName) {
        changed = true;
        return { ...normalizedCol, name: baseName, createdAt };
      }
      return normalizedCol;
    }

    const legacyMatch = LEGACY_TIMESTAMP_REGEX.exec(normalizedCol.name || '');
    const weekdayMatch = LEGACY_WEEKDAY_REGEX.exec(normalizedCol.name || '');
    if (!legacyMatch && !weekdayMatch) return normalizedCol;

    const suffix = legacyMatch?.[2];
    const nextName = suffix ? `${baseName} \u00b7 ${suffix}` : baseName;
    changed = true;
    return {
      ...normalizedCol,
      name: nextName,
      autoTitleType: 'timeOfDay',
      createdAt,
    };
  });
  const metadataNormalized = normalizeCollectionMetadata(changed ? next : collections);
  return {
    collections: metadataNormalized.collections,
    changed: changed || metadataNormalized.changed,
  };
}

const Storage = {
  // ── Core getters ───────────────────────────────────────

  async getAll() {
    const data = await chrome.storage.local.get(['collections', 'urlIndex', 'settings', 'actionLog']);
    const normalized = normalizeAutoTitles(data.collections || []);
    if (normalized.changed) {
      await chrome.storage.local.set({ collections: normalized.collections });
    }
    return {
      collections: normalized.collections,
      urlIndex: data.urlIndex || {},
      settings: { ...DEFAULT_SETTINGS, ...data.settings },
      actionLog: data.actionLog || [],
    };
  },

  async getCollections() {
    const { collections } = await chrome.storage.local.get('collections');
    const normalized = normalizeAutoTitles(collections || []);
    if (normalized.changed) {
      await chrome.storage.local.set({ collections: normalized.collections });
    }
    return normalized.collections;
  },

  async saveCollections(collections) {
    await chrome.storage.local.set({ collections });
  },

  async getSettings() {
    const { settings } = await chrome.storage.local.get('settings');
    return { ...DEFAULT_SETTINGS, ...settings };
  },

  async saveSettings(settings) {
    await chrome.storage.local.set({ settings });
  },

  // ── Action Log ──────────────────────────────────────────

  async logAction(type, details = {}) {
    const { actionLog } = await chrome.storage.local.get('actionLog');
    const log = actionLog || [];
    log.push({
      type,
      timestamp: Date.now(),
      ...details,
    });
    // Cap at 10k entries to avoid storage bloat
    if (log.length > 10000) log.splice(0, log.length - 10000);
    await chrome.storage.local.set({ actionLog: log });
  },

  async getActionLog() {
    const { actionLog } = await chrome.storage.local.get('actionLog');
    return actionLog || [];
  },

  // ── URL Index ──────────────────────────────────────────

  async getUrlIndex() {
    const { urlIndex } = await chrome.storage.local.get('urlIndex');
    return urlIndex || {};
  },

  async saveUrlIndex(urlIndex) {
    await chrome.storage.local.set({ urlIndex });
  },

  async rebuildUrlIndex() {
    const collections = await this.getCollections();
    const idx = {};
    for (const col of collections) {
      for (const tab of col.tabs) {
        idx[tab.url] = (idx[tab.url] || 0) + 1;
      }
    }
    await this.saveUrlIndex(idx);
    return idx;
  },

  // ── Collections CRUD ───────────────────────────────────

  async addCollection(name, tabs, options = {}) {
    const data = await chrome.storage.local.get(['collections', 'urlIndex']);
    const collections = data.collections || [];
    const urlIndex = data.urlIndex || {};
    const createdAt = options.createdAt || Date.now();

    const collection = {
      id: crypto.randomUUID(),
      name,
      createdAt,
      autoTitleType: options.autoTitleType,
      isUserNamed: Boolean(options.isUserNamed),
      isPinned: options.isPinned || false,
      notes: options.notes || '',
      archived: false,
      lastInteractedAt: createdAt,
      tabs: tabs.map((t) => ({
        id: crypto.randomUUID(),
        url: t.url,
        title: t.title || t.url,
        favIconUrl: t.favIconUrl || '',
        savedAt: Date.now(),
        archived: false,
        tags: t.tags || [],
      })),
    };

    // Update URL index
    for (const tab of collection.tabs) {
      urlIndex[tab.url] = (urlIndex[tab.url] || 0) + 1;
    }

    collections.unshift(collection);
    await chrome.storage.local.set({ collections, urlIndex });

    await this.logAction('save', {
      collectionId: collection.id,
      tabCount: collection.tabs.length,
    });

    return collection;
  },

  async getDuplicateCounts() {
    const urlIndex = await this.getUrlIndex();
    return new Map(Object.entries(urlIndex));
  },

  async removeTab(tabId) {
    const data = await chrome.storage.local.get(['collections', 'urlIndex']);
    const collections = data.collections || [];
    const urlIndex = data.urlIndex || {};

    for (const col of collections) {
      const idx = col.tabs.findIndex((t) => t.id === tabId);
      if (idx !== -1) {
        const tab = col.tabs[idx];
        if (urlIndex[tab.url]) {
          urlIndex[tab.url]--;
          if (urlIndex[tab.url] <= 0) delete urlIndex[tab.url];
        }
        col.tabs.splice(idx, 1);
        await this.logAction('delete', { tabId, collectionId: col.id });
        break;
      }
    }

    const filtered = collections.filter((c) => c.tabs.length > 0 || c.isPinned);
    await chrome.storage.local.set({ collections: filtered, urlIndex });
  },

  async moveTab(tabId, targetCollectionId, targetIndex = null) {
    const collections = await this.getCollections();
    let tab = null;
    let sourceCollection = null;

    for (const col of collections) {
      const idx = col.tabs.findIndex((t) => t.id === tabId);
      if (idx !== -1) {
        tab = col.tabs.splice(idx, 1)[0];
        sourceCollection = col;
        break;
      }
    }

    if (!tab) return;

    const target = collections.find((c) => c.id === targetCollectionId);
    if (target) {
      const appendIndex = target.tabs.length;
      const resolvedIndex = Number.isInteger(targetIndex) ? targetIndex : appendIndex;
      const insertAt = Math.max(0, Math.min(resolvedIndex, appendIndex));
      target.tabs.splice(insertAt, 0, tab);
      target.lastInteractedAt = Date.now();
    }

    if (sourceCollection) {
      sourceCollection.lastInteractedAt = Date.now();
    }

    const filtered = collections.filter((c) => c.tabs.length > 0 || c.isPinned);
    await this.saveCollections(filtered);
  },

  async updateTab(tabId, updates) {
    const data = await chrome.storage.local.get(['collections', 'urlIndex']);
    const collections = data.collections || [];
    const urlIndex = data.urlIndex || {};

    for (const col of collections) {
      const tab = col.tabs.find((t) => t.id === tabId);
      if (!tab) continue;

      const oldUrl = tab.url;
      const newUrl = updates.url ?? tab.url;

      if (oldUrl && oldUrl !== newUrl && urlIndex[oldUrl]) {
        urlIndex[oldUrl]--;
        if (urlIndex[oldUrl] <= 0) delete urlIndex[oldUrl];
      }

      if (updates.title !== undefined) tab.title = updates.title;
      if (updates.url !== undefined) tab.url = updates.url;

      if (newUrl && oldUrl !== newUrl) {
        urlIndex[newUrl] = (urlIndex[newUrl] || 0) + 1;
      }

      await chrome.storage.local.set({ collections, urlIndex });
      await this.logAction('edit', { tabId, collectionId: col.id });
      return tab;
    }

    return null;
  },

  async removeCollection(collectionId) {
    const data = await chrome.storage.local.get(['collections', 'urlIndex']);
    const collections = data.collections || [];
    const urlIndex = data.urlIndex || {};

    const col = collections.find((c) => c.id === collectionId);
    if (col) {
      for (const tab of col.tabs) {
        if (urlIndex[tab.url]) {
          urlIndex[tab.url]--;
          if (urlIndex[tab.url] <= 0) delete urlIndex[tab.url];
        }
      }
      await this.logAction('delete', { collectionId });
    }

    const filtered = collections.filter((c) => c.id !== collectionId);
    await chrome.storage.local.set({ collections: filtered, urlIndex });
  },

  async setCollectionArchived(collectionId, archived) {
    const collections = await this.getCollections();
    const col = collections.find((c) => c.id === collectionId);
    if (!col) return null;
    col.archived = Boolean(archived);
    await this.saveCollections(collections);
    return col;
  },

  async setTabArchived(tabId, archived) {
    const collections = await this.getCollections();
    for (const col of collections) {
      const tab = col.tabs.find((t) => t.id === tabId);
      if (!tab) continue;
      tab.archived = Boolean(archived);
      await this.saveCollections(collections);
      return tab;
    }
    return null;
  },

  async replaceState(collections, urlIndex) {
    await chrome.storage.local.set({ collections, urlIndex });
  },

  async renameCollection(collectionId, newName) {
    const collections = await this.getCollections();
    const col = collections.find((c) => c.id === collectionId);
    if (col) {
      col.name = newName;
      col.isUserNamed = true;
      col.lastInteractedAt = Date.now();
      delete col.autoTitleType;
      await this.saveCollections(collections);
    }
  },

  async markCollectionInteracted(collectionId) {
    const collections = await this.getCollections();
    const col = collections.find((c) => c.id === collectionId);
    if (!col) return null;
    col.lastInteractedAt = Date.now();
    await this.saveCollections(collections);
    return col.lastInteractedAt;
  },

  async reorderCollections(orderedIds) {
    const collections = await this.getCollections();
    const idToCollection = new Map(collections.map((col) => [col.id, col]));
    const ordered = [];

    for (const id of orderedIds) {
      const col = idToCollection.get(id);
      if (!col) continue;
      ordered.push(col);
      idToCollection.delete(id);
    }

    for (const col of idToCollection.values()) {
      ordered.push(col);
    }

    await this.saveCollections(ordered);
    return ordered;
  },

  async reorderTabs(collectionId, orderedTabIds) {
    const collections = await this.getCollections();
    const col = collections.find((c) => c.id === collectionId);
    if (!col) return null;

    const idToTab = new Map(col.tabs.map((tab) => [tab.id, tab]));
    const ordered = [];

    for (const tabId of orderedTabIds) {
      const tab = idToTab.get(tabId);
      if (!tab) continue;
      ordered.push(tab);
      idToTab.delete(tabId);
    }

    for (const tab of idToTab.values()) {
      ordered.push(tab);
    }

    col.tabs = ordered;
    await this.saveCollections(collections);
    return col.tabs;
  },

  // ── Pin / Unpin ────────────────────────────────────────

  async togglePin(collectionId) {
    const collections = await this.getCollections();
    const col = collections.find((c) => c.id === collectionId);
    if (col) {
      col.isPinned = !col.isPinned;
      await this.saveCollections(collections);
      return col.isPinned;
    }
    return false;
  },

  // ── Notes ──────────────────────────────────────────────

  async updateNotes(collectionId, notes) {
    const collections = await this.getCollections();
    const col = collections.find((c) => c.id === collectionId);
    if (col) {
      col.notes = notes;
      await this.saveCollections(collections);
    }
  },

  // ── Tags ───────────────────────────────────────────────

  async addTag(tabId, tag) {
    const collections = await this.getCollections();
    for (const col of collections) {
      const tab = col.tabs.find((t) => t.id === tabId);
      if (tab) {
        if (!tab.tags) tab.tags = [];
        const normalized = tag.trim().toLowerCase();
        if (normalized && !tab.tags.includes(normalized)) {
          tab.tags.push(normalized);
          col.lastInteractedAt = Date.now();
          await this.saveCollections(collections);
          await this.logAction('tag', { tabId, tag: normalized });
        }
        return tab.tags;
      }
    }
    return [];
  },

  async removeTag(tabId, tag) {
    const collections = await this.getCollections();
    for (const col of collections) {
      const tab = col.tabs.find((t) => t.id === tabId);
      if (tab) {
        if (!tab.tags) tab.tags = [];
        const beforeCount = tab.tags.length;
        tab.tags = tab.tags.filter((t) => t !== tag);
        if (tab.tags.length !== beforeCount) {
          col.lastInteractedAt = Date.now();
        }
        await this.saveCollections(collections);
        return tab.tags;
      }
    }
    return [];
  },

  // ── Duplicate merging ──────────────────────────────────

  async mergeDuplicates(url, targetCollectionId) {
    const data = await chrome.storage.local.get(['collections', 'urlIndex']);
    const collections = data.collections || [];
    const urlIndex = data.urlIndex || {};

    const instances = [];
    for (const col of collections) {
      for (let i = col.tabs.length - 1; i >= 0; i--) {
        if (col.tabs[i].url === url) {
          instances.push({ col, tab: col.tabs[i], idx: i });
        }
      }
    }

    if (instances.length <= 1) return 0;

    const earliestSavedAt = Math.min(...instances.map((i) => i.tab.savedAt));
    const bestTitle = instances
      .map((i) => i.tab.title)
      .filter((t) => t !== url)
      .sort((a, b) => b.length - a.length)[0] || url;

    const allTags = [...new Set(instances.flatMap((i) => i.tab.tags || []))];

    for (const inst of instances) {
      const idx = inst.col.tabs.indexOf(inst.tab);
      if (idx !== -1) inst.col.tabs.splice(idx, 1);
    }

    const target = collections.find((c) => c.id === targetCollectionId)
      || instances[0].col;
    target.tabs.unshift({
      id: crypto.randomUUID(),
      url,
      title: bestTitle,
      favIconUrl: instances[0].tab.favIconUrl,
      savedAt: earliestSavedAt,
      archived: false,
      tags: allTags,
    });

    urlIndex[url] = 1;

    const filtered = collections.filter((c) => c.tabs.length > 0 || c.isPinned);
    await chrome.storage.local.set({ collections: filtered, urlIndex });
    return instances.length - 1;
  },

  async mergeAllDuplicates() {
    const data = await chrome.storage.local.get(['collections', 'urlIndex']);
    const collections = data.collections || [];
    const urlIndex = data.urlIndex || {};

    const urlMap = {};
    for (const col of collections) {
      for (const tab of col.tabs) {
        if (!urlMap[tab.url]) urlMap[tab.url] = [];
        urlMap[tab.url].push({ col, tab });
      }
    }

    let totalRemoved = 0;

    for (const [url, instances] of Object.entries(urlMap)) {
      if (instances.length <= 1) continue;

      const earliestSavedAt = Math.min(...instances.map((i) => i.tab.savedAt));
      const bestTitle = instances
        .map((i) => i.tab.title)
        .filter((t) => t !== url)
        .sort((a, b) => b.length - a.length)[0] || url;
      const favIcon = instances[0].tab.favIconUrl;
      const targetCol = instances[0].col;
      const allTags = [...new Set(instances.flatMap((i) => i.tab.tags || []))];

      for (const inst of instances) {
        const idx = inst.col.tabs.indexOf(inst.tab);
        if (idx !== -1) inst.col.tabs.splice(idx, 1);
      }

      targetCol.tabs.unshift({
        id: crypto.randomUUID(),
        url,
        title: bestTitle,
        favIconUrl: favIcon,
        savedAt: earliestSavedAt,
        archived: false,
        tags: allTags,
      });

      urlIndex[url] = 1;
      totalRemoved += instances.length - 1;
    }

    const filtered = collections.filter((c) => c.tabs.length > 0 || c.isPinned);
    await chrome.storage.local.set({ collections: filtered, urlIndex });
    return totalRemoved;
  },

  // ── Export ─────────────────────────────────────────────

  exportCollectionAsMarkdown(col) {
    const lines = [`# ${col.name}`, ''];
    if (col.notes) {
      lines.push(col.notes, '');
    }

    for (const tab of col.tabs) {
      const tagStr = tab.tags?.length ? ` \`${tab.tags.join('` `')}\`` : '';
      lines.push(`- [${tab.title}](${tab.url})${tagStr}`);
    }
    return lines.join('\n');
  },

  // ── Search ─────────────────────────────────────────────

  search(collections, query, filters = {}) {
    const q = query.toLowerCase().trim();
    if (!q) return [];

    const tokens = q.split(/\s+/).filter(Boolean);
    const {
      pinnedOnly = false,
      last7Days = false,
      domain = '',
    } = filters;
    const domainQuery = domain.toLowerCase().trim();
    const sinceTs = last7Days ? Date.now() - 7 * 24 * 60 * 60 * 1000 : null;

    const results = [];
    for (const col of collections) {
      if (pinnedOnly && !col.isPinned) continue;
      const collectionName = (col.name || '').toLowerCase();
      const collectionMatch = tokens.every((token) => collectionName.includes(token));
      for (const tab of col.tabs) {
        if (sinceTs && tab.savedAt < sinceTs) continue;
        if (domainQuery) {
          try {
            const host = new URL(tab.url).hostname.toLowerCase();
            if (!host.includes(domainQuery)) continue;
          } catch {
            continue;
          }
        }
        const tagStr = (tab.tags || []).join(' ');
        const haystack = (tab.title + ' ' + tab.url + ' ' + tagStr + ' ' + collectionName).toLowerCase();
        const match = collectionMatch || tokens.every((token) => haystack.includes(token));
        if (match) {
          results.push({
            ...tab,
            collectionId: col.id,
            collectionName: col.name,
            collectionArchived: Boolean(col.archived),
            archived: Boolean(tab.archived),
          });
        }
      }
    }
    return results;
  },

  // ── Manual tab ──────────────────────────────────────────

  async addManualTab(collectionId, title, url) {
    const data = await chrome.storage.local.get(['collections', 'urlIndex']);
    const collections = data.collections || [];
    const urlIndex = data.urlIndex || {};

    const col = collections.find((c) => c.id === collectionId);
    if (!col) return null;

    const tab = {
      id: crypto.randomUUID(),
      url,
      title: title || url,
      favIconUrl: '',
      savedAt: Date.now(),
      archived: false,
      tags: [],
    };

    col.tabs.push(tab);
    col.lastInteractedAt = Date.now();
    urlIndex[url] = (urlIndex[url] || 0) + 1;

    await chrome.storage.local.set({ collections, urlIndex });
    await this.logAction('save', { collectionId, tabId: tab.id });
    return tab;
  },

  async autoArchiveInactiveSessions(now = Date.now(), thresholdMs = 14 * 24 * 60 * 60 * 1000) {
    const collections = await this.getCollections();
    const cutoff = now - thresholdMs;
    let changed = false;

    for (const col of collections) {
      if (col.archived || col.isPinned || col.isUserNamed) continue;
      const referenceTs = col.lastInteractedAt || col.createdAt || 0;
      if (referenceTs <= cutoff) {
        col.archived = true;
        changed = true;
      }
    }

    if (changed) {
      await this.saveCollections(collections);
    }

    return changed;
  },

  // ── Sorting helper ────────────────────────────────────

  sortCollections(collections, sortMode = DEFAULT_SETTINGS.collectionSort) {
    const ordered = [...collections];
    const sortByCreatedAt = (a, b) => (a.createdAt || 0) - (b.createdAt || 0);
    const sortByName = (a, b) => (a.name || '').localeCompare((b.name || ''), undefined, { sensitivity: 'base' });

    if (sortMode === 'oldest') {
      ordered.sort(sortByCreatedAt);
    } else if (sortMode === 'az') {
      ordered.sort(sortByName);
    } else if (sortMode === 'za') {
      ordered.sort((a, b) => sortByName(b, a));
    } else {
      ordered.sort((a, b) => sortByCreatedAt(b, a));
    }

    return ordered;
  },
};

if (typeof globalThis !== 'undefined') {
  globalThis.WhyTabStorage = Storage;
}
